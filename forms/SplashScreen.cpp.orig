#include "SplashScreen.h"
#include "config.h"
#include "ui_SplashScreen.h"
#include "Actor.h"
#include "Scene.h"
#include <QFutureSynchronizer>
#include <QtConcurrent>
#include <QtConcurrentRun>
SplashScreen::SplashScreen(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::SplashScreen),
    scenesBuilt(false), actorsBuilt(false), scenesLoaded(false), actorsLoaded(false)
{
    ui->setupUi(this);
    checkForDataDirectories();
    progressList << ui->pb_loadActors << ui->pb_loadScenes << ui->pb_buildActors << ui->pb_buildScenes;
    foreach(QProgressBar *pb, progressList){
        pb->setMinimum(0);
        pb->setValue(0);
    }
<<<<<<< HEAD
    this->scenes = {};
    this->actors = {};
    this->actorBuildThreadDone = false;
    this->sceneBuildThreadDone = false;
=======
>>>>>>> 62d3ccba5faac19dec21229a21dbaa2b032d4fe7
}

void SplashScreen::showEvent(QShowEvent *){
    this->sceneLoadThread = new miniSQL("scenes");
    this->actorLoadThread = new miniSQL("actors");
    connect(sceneLoadThread, SIGNAL(closeProgress(int)),      this, SLOT(finishProgress(int)));
    connect(actorLoadThread, SIGNAL(closeProgress(int)),      this, SLOT(finishProgress(int)));
    connect(sceneLoadThread, SIGNAL(startProgress(int,int)),  this, SLOT(startProgress(int,int)));
    connect(actorLoadThread, SIGNAL(startProgress(int,int)),  this, SLOT(startProgress(int,int)));
    connect(sceneLoadThread, SIGNAL(updateProgress(int,int)), this, SLOT(updateProgress(int,int)));
    connect(actorLoadThread, SIGNAL(updateProgress(int,int)), this, SLOT(updateProgress(int,int)));
    connect(sceneLoadThread, SIGNAL(done(SceneMap)),         this, SLOT(receiveScenes(SceneMap)));
    connect(actorLoadThread, SIGNAL(done(ActorMap)),         this, SLOT(receiveActors(ActorMap)));
    connect(this, SIGNAL(completed(int)), this, SLOT(stepComplete(int)));
    sceneLoadThread->start();
    actorLoadThread->start();
}
void SplashScreen::closeEvent(QCloseEvent *event){
    event->accept();
}

SplashScreen::~SplashScreen(){
    delete ui;
}

void SplashScreen::startProgress(int ID, int max){
    if (ID < progressList.size() && ID > -1){
        progressList.at(ID)->setMaximum(max);
    }
}
void SplashScreen::updateProgress(int ID, int value){
    if (ID < progressList.size() && ID > -1){
        progressList.at(ID)->setValue(value);
    }
}
void SplashScreen::finishProgress(int ID){
    if (ID < progressList.size() && ID > -1){
        progressList.at(ID)->setValue(progressList.at(ID)->maximum());
    }
}
<<<<<<< HEAD
void SplashScreen::actorBuildThreadFinished(){
    this->actorBuildThreadDone = true;
    qDebug("Actor Build Thread finished");
}
void SplashScreen::sceneBuildThreadFinished(){
    this->sceneBuildThreadDone = true;
    qDebug("Scene Build Thread Finished");
}

void SplashScreen::receiveActors(ActorList list){
    this->actors = list;
    qDebug("Starting to build %d actor display items", list.size());
    emit completed(LOAD_ACTOR_PROGRESS);
    QMutexLocker ml(&mx);
    this->actorBuild = new DisplayMaker(actors, this);
    connect(actorBuild, SIGNAL(done(RowList)),      this, SLOT(receiveActorDisplay(RowList)));
    connect(actorBuild, SIGNAL(startRun(int,int)),  this, SLOT(startProgress(int,int)));
    connect(actorBuild, SIGNAL(stopRun(int)),       this, SLOT(finishProgress(int)));
    connect(actorBuild, SIGNAL(update(int,int)),    this, SLOT(updateProgress(int,int)));
    connect(actorBuild, SIGNAL(finished()),         this, SLOT(sceneBuildThreadFinished()));
=======
void SplashScreen::receiveActors(ActorMap list){
    this->actorMap = list;
    emit sendActors(list);
    qDebug("Starting to build %d actor display items", list.size());
    emit completed(LOAD_ACTOR_PROGRESS);
    QMutexLocker ml(&mx);
    this->actorBuild = new DisplayMaker(actorMap);
    connect(actorBuild, SIGNAL(done(RowList)),      this, SIGNAL(sendActorRows(RowList)));
    connect(actorBuild, &DisplayMaker::done,        [=]{  stepComplete(BUILD_ACTOR_PROGRESS);   });
    connect(actorBuild, SIGNAL(startRun(int,int)),  this, SLOT(startProgress(int,int)));
    connect(actorBuild, SIGNAL(stopRun(int)),       this, SLOT(finishProgress(int)));
    connect(actorBuild, SIGNAL(update(int,int)),    this, SLOT(updateProgress(int,int)));
>>>>>>> 62d3ccba5faac19dec21229a21dbaa2b032d4fe7
    actorBuild->start();
}

void SplashScreen::receiveScenes(SceneMap list){
    this->sceneMap = list;
    emit sendScenes(list);
    qDebug("Starting to build %d scene display items", list.size());
    emit completed(LOAD_SCENE_PROGRESS);
    QMutexLocker ml(&mx);
<<<<<<< HEAD
    this->sceneBuild = new DisplayMaker(scenes, this);
    connect(sceneBuild, SIGNAL(done(RowList)),      this, SLOT(receiveSceneDisplay(RowList)));
    connect(sceneBuild, SIGNAL(startRun(int,int)),  this, SLOT(startProgress(int,int)));
    connect(sceneBuild, SIGNAL(stopRun(int)),       this, SLOT(finishProgress(int)));
    connect(sceneBuild, SIGNAL(update(int,int)),    this, SLOT(updateProgress(int,int)));
    connect(sceneBuild, SIGNAL(finished()),         this, SLOT(actorBuildThreadFinished()));
=======
    this->sceneBuild = new DisplayMaker(sceneMap);
    connect(sceneBuild, SIGNAL(done(RowMap)),       this, SIGNAL(sendSceneRows(RowList)));
    connect(sceneBuild, &DisplayMaker::done,        [=]{  stepComplete(BUILD_SCENE_PROGRESS); });
    connect(sceneBuild, SIGNAL(startRun(int,int)),  this, SLOT(startProgress(int,int)));
    connect(sceneBuild, SIGNAL(stopRun(int)),       this, SLOT(finishProgress(int)));
    connect(sceneBuild, SIGNAL(update(int,int)),    this, SLOT(updateProgress(int,int)));
>>>>>>> 62d3ccba5faac19dec21229a21dbaa2b032d4fe7
    sceneBuild->start();
}

void SplashScreen::stepComplete(int progress){
    QMutexLocker ml(&mx);
    if (progress == LOAD_ACTOR_PROGRESS){
        this->actorsLoaded = true;
        this->actorLoadThread->deleteLater();
    } else if (progress == LOAD_SCENE_PROGRESS){
        this->scenesLoaded = true;
        this->sceneLoadThread->deleteLater();
    } else if (progress == BUILD_ACTOR_PROGRESS){
        this->actorsBuilt = true;
        if (actorBuild){
            this->actorBuild->quit();
            this->actorBuild->wait();
            this->actorBuild->deleteLater();
        }
    } else if (progress == BUILD_SCENE_PROGRESS){
        this->scenesBuilt = true;
        if (sceneBuild){
            this->sceneBuild->quit();
            this->sceneBuild->wait();
            this->sceneBuild->deleteLater();
        }
    }
    qDebug("\nIndex %d Finished\n", progress);
    progressList[progress]->setRange(0, 100);
    progressList[progress]->setValue(100);
    if (actorsLoaded && scenesLoaded && actorsBuilt && scenesBuilt){
        ml.unlock();
        qDebug("Initialization Finished");
        emit done(actors, scenes, actorRows, sceneRows);
    }
}

void SplashScreen::receiveActorDisplay(RowList rows){
//    this->actorRows = rows;
    qDebug("Got %d actor rows", rows.size());
<<<<<<< HEAD
    //this->actorBuild->quit();
    emit completed(BUILD_ACTOR_PROGRESS);
=======
//    emit sendActorRows(rows);
//    emit completed(BUILD_ACTOR_PROGRESS);
>>>>>>> 62d3ccba5faac19dec21229a21dbaa2b032d4fe7
}
void SplashScreen::receiveSceneDisplay(RowList rows){
//    this->sceneRows = rows;
    qDebug("Got %d scene Rows", rows.size());
<<<<<<< HEAD
    //this->sceneBuild->quit();
    emit completed(BUILD_SCENE_PROGRESS);
}
=======
//    emit sendSceneRows(sceneRows);
//    emit completed(BUILD_SCENE_PROGRESS);
>>>>>>> 62d3ccba5faac19dec21229a21dbaa2b032d4fe7

}

void DisplayMaker::run(){
    this->index = 0;
    int id = -1;
    QFutureSynchronizer<void> sync;
    if (listType == "actors"){
        id = BUILD_ACTOR_PROGRESS;
        emit startRun(BUILD_ACTOR_PROGRESS, actorMap.size());
        QHashIterator<QString, ActorPtr> it(actorMap);
        while(it.hasNext()){
            it.next();
            sync.addFuture(QtConcurrent::run(this, &DisplayMaker::makeActorRow, it.value()));
        }
    } else {
        id = BUILD_SCENE_PROGRESS;
        emit startRun(BUILD_SCENE_PROGRESS, sceneMap.size());
        QHashIterator<int, ScenePtr> it(sceneMap);
        while(it.hasNext()){
            it.next();
            sync.addFuture(QtConcurrent::run(this, &DisplayMaker::makeSceneRow, it.value()));
        }
    }
    sync.waitForFinished();
    emit done(rows);
}

void DisplayMaker::makeActorRow(ActorPtr a){
    QList<QStandardItem *> row = a->buildQStandardItem();
    QMutexLocker ml(&mx);
    this->rows << row;
    if (++index % 50 == 0){
        emit update(BUILD_ACTOR_PROGRESS, index);
    }
}
void DisplayMaker::makeSceneRow(ScenePtr s){
    QList<QStandardItem*>row = s->buildQStandardItem();
    QMutexLocker ml(&mx);
    this->rows << row;
    if (++index %100 == 0){
        emit update(BUILD_SCENE_PROGRESS, index);
    }
}

void miniSQL::run(){
    const int task = ((currentTable==SCENE) ? LOAD_SCENE_PROGRESS : LOAD_ACTOR_PROGRESS);
    QString statement = QString("SELECT * FROM %1").arg((currentTable==SCENE) ? "scenes" : "actors");
    sqlConnection connection(statement);
    if (!connection.execute()){
        qWarning("Error Loading items from database!");
    } else {
        pqxx::result r = connection.getResult();
        if (r.size() == 0){
            qWarning("No Items in table");
            return;
        }
        emit startProgress(task, r.size());
        for(pqxx::result::const_iterator i = r.begin(); i != r.end(); ++i){
            if (currentTable == SCENE){
                sceneMap.push_back(ScenePtr(new Scene(i)));
            } else {
                actorMap.push_back(ActorPtr(new Actor(i)));
            }
            emit updateProgress(task, i);
        }
        int items = ((currentTable == SCENE) ? sceneMap.size() : actorMap.size());
        qDebug("miniSQL Thread loaded %d items with '%s'", items, qPrintable(statement));
        emit closeProgress(task);
    }
    if (currentTable == SCENE){
        emit done(sceneMap);
    } else {
        emit done(actorMap);
    }
}

